esphome:
  name: stairwell-effects
  friendly_name: stairwell_effects
  on_boot:
    priority: -10
    then:
      - light.turn_off: stair_light
      - lambda: |
          id(system_state) = 0;
          id(up_sequence_active) = false;
          id(down_sequence_active) = false;
          id(effect_finished) = false;
          id(last_trigger_time) = 0;
          id(last_pir) = 0;

esp8266:
  board: esp01_1m

# Enable logging
logger:
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Stairwell-Effects"
    password: !secret sw_effect_ap_pass

captive_portal:

api:

ota:
  - platform: esphome
    password: !secret sw_effect_ota

web_server:
  version: 3


globals:
  ## need to clean up the globals
  - id: light_state
    type: int
    restore_value: no
    initial_value: '0' # 0 = off, 1 = low to high, 2 = high to low
  - id: cooldown_active
    type: bool
    initial_value: 'false'
  - id: upper_pir_time
    type: long
    initial_value: '0'
  - id: lower_pir_time
    type: long
    initial_value: '0'
  - id: up_sequence_active
    type: bool
    initial_value: 'false'
  - id: down_sequence_active
    type: bool
    initial_value: 'false'
  - id: last_pir
    type: int
    initial_value: '0'  # 0 = none, 1 = lower PIR, 2 = upper PIR
  - id: progress
    type: int
    restore_value: no
    initial_value: '0'
  - id: led_group_size
    type: int
    restore_value: yes
    initial_value: '10' # Default group size
  - id: led_gap_size
    type: int
    restore_value: yes
    initial_value: '5' # Default gap size
  - id: timeout_active
    type: bool
    restore_value: no
    initial_value: 'false'
# Used to track last triggered 
  - id: last_trigger_time
    type: long
    initial_value: '0'
  - id: last_pir_cleared_time
    type: long
    initial_value: '0'
  - id: effect_finished  # New global to track effect completion
    type: bool
    initial_value: 'false'


## Would like to add a system status that encorporates multiple globals.  for example
  - id: system_state
    type: int
    initial_value: '0'  # 0 = idle, 1 = up_active, 2 = down_active, 3 = cooling_down
## From the i could Update logic to use system_state instead of multiple booleans:
## Example
#- lambda: |
#    if (id(system_state) == 0) {  // Idle
#      id(last_trigger_time) = millis();
#      id(system_state) = 1;       // Up active
#    }

## Ambient Light Sensor
#sensor:
#  - platform: bh1750
#    name: "Ambient Light"
#    id: ambient_light
#    update_interval: 60s
#light:
#  - platform: neopixelbus
#    ...
#    on_state:
#      then:
#        - lambda: |
#            if (id(ambient_light).state < 50) {  // Lux threshold
#              id(stair_light).turn_on().set_brightness(0.8);
#            } else {
#              id(stair_light).turn_on().set_brightness(0.4);
#            }

number:
  - platform: template
    name: "LED Group Size"
    id: led_group_size_number
    min_value: 1
    max_value: 4 # Adjust as needed
    step: 1
    restore_value: yes
    optimistic: true
    set_action:
      - lambda: 'id(led_group_size) = x;'

  - platform: template
    name: "LED Gap Size"
    id: led_gap_size_number
    min_value: 0
    max_value: 20 # Adjust as needed
    step: 1
    restore_value: yes
    optimistic: true
    set_action:
      - lambda: 'id(led_gap_size) = x;'



binary_sensor:
  - platform: gpio
    pin:
      number: 12
      #mode: INPUT_PULLUP
      #inverted: true 
    name: "PIR Sensor (Upper)"
    id: upper_pir_sensor
    filters:
      - delayed_on: 100ms  # Debounce on
      - delayed_off: 200ms # Debounce off    
    device_class: motion
    on_press:
      then:
        - if:
            condition:
               lambda: 'return ((!id(up_sequence_active) && !id(down_sequence_active)) || (!id(up_sequence_active) && id(light_state) == 0));'  # Only trigger if no sequence is active
              #lambda: 'return id(up_sequence_active) == false;'
            then:
              - light.turn_on:
                  id: stair_light
                  effect: "Fade on DOWN"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(down_sequence_active) = true;
                  id(effect_finished) = false;
                  id(last_trigger_time) = millis();
                  id(last_pir) = 2;
                  id(light_state) = 1;
                #- delay: 6s
          ## same trigger going up half way then back down 
        - if:
            condition:
              lambda: 'return (id(effect_finished) && id(last_pir) == 2 && id(down_sequence_active) && id(light_state) == 1 );'
              #lambda: 'return (id(last_trigger_time) > 4000 && id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
              #lambda: 'return (id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
            then:
              - light.turn_on:
                  id: stair_light
                  effect: "Fade off UP"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(down_sequence_active) = false;
                  id(effect_finished) = false;
                  id(last_trigger_time) = 0;
                  id(last_pir) = 0;
                  id(light_state) = 0;


    on_release:
      then:
        - lambda: 'id(last_pir_cleared_time) = millis();'
        - if:
            condition:
              lambda: 'return (id(up_sequence_active) == true && id(down_sequence_active) == false);'
            then:
              - wait_until:
                  condition:
                    binary_sensor.is_off: upper_pir_sensor
                  timeout: 30s
              - light.turn_on:
                  id: stair_light
                  effect: "Fade off UP"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(up_sequence_active) = false;
                  id(effect_finished) = false;
                  id(last_pir_cleared_time) = 0;
                  id(last_trigger_time) = 0;

              - delay: 
                  6s
              - light.turn_off:
                  id: stair_light              


  - platform: gpio
    pin:
      number: 14
      #mode: INPUT_PULLUP
      #inverted: true 
    name: "PIR Sensor (Lower)"
    id: lower_pir_sensor
    device_class: motion
    filters:
      - delayed_on: 100ms  # Debounce on
      - delayed_off: 200ms # Debounce off    
    on_press:
        then:
          #- lambda: |-
          #      ESP_LOGD("Global Variables", "PIR Sensor (Lower) before condition");
          #      ESP_LOGD("Global Variables", "light_state: %i", id(light_state));
          #      ESP_LOGD("Global Variables", "up_sequence_active: %s", id(up_sequence_active) ? "true" : "false");
          #      ESP_LOGD("Global Variables", "down_sequence_active: %s", id(down_sequence_active) ? "true" : "false");
          #      ESP_LOGD("Global Variables", "last_pir: %i", id(last_pir));
          #      ESP_LOGD("Global Variables", "last_trigger_time: %li", id(last_trigger_time));
          #      ESP_LOGD("Global Variables", "last_pir_cleared_time: %li", id(last_pir_cleared_time));
          #      ESP_LOGD("Global Variables", "effect_finished: %s", id(effect_finished) ? "true" : "false");

          ## new trigger
          - if:
              condition:
                and:
                  - lambda: 'return ((!id(up_sequence_active) && !id(down_sequence_active)) || (!id(down_sequence_active) && id(light_state) == 0));'
                  #- lambda: 'return id(last_pir) == 1 && (millis() - id(last_trigger_time)) < 5000;'
                  #- binary_sensor.is_on: lower_pir_sensor
              then:
                - light.turn_on:
                    id: stair_light
                    effect: "Fade on UP"
                - wait_until:
                    condition:
                      lambda: 'return id(effect_finished);'
                - lambda: |
                    id(up_sequence_active) = true;
                    id(effect_finished) = false;
                    id(last_trigger_time) = millis();
                    id(last_pir) = 1;
                    id(light_state) = 1;
                #- delay: 6s
          ## same trigger going up half way then back down 
          - if:
              condition:
                and:
                  - lambda: 'return (id(effect_finished) && id(last_pir) == 1 && id(up_sequence_active) && id(light_state) == 1 );'
                  #- lambda: 'return id(last_pir) == 1 && (millis() - id(last_trigger_time)) < 5000;'
                  #- binary_sensor.is_on: lower_pir_sensor
                  # - lambda: 'return (id(last_trigger_time) > 4000 && id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
                  # - lambda: 'return (id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
                  # - lambda: 'return (millis() - id(last_trigger_time)) > 500;'  # 500ms cooldown
              then:
                - light.turn_on:
                    id: stair_light
                    effect: "Fade off Down"
                - wait_until:
                    condition:
                      lambda: 'return id(effect_finished);'
                - lambda: |
                    id(up_sequence_active) = false;
                    id(effect_finished) = false;
                    id(last_trigger_time) = 0;
                    id(last_pir) = 0;
                    id(light_state) = 0;

    on_release:
      then:
        - lambda: 'id(last_pir_cleared_time) = millis();'
        - if:
            condition:
              lambda: 'return (id(down_sequence_active) == true && id(up_sequence_active) == false);'
            then:
              - wait_until:
                  condition:
                    binary_sensor.is_off: lower_pir_sensor
                  timeout: 30s
              - light.turn_on:
                  id: stair_light
                  effect: "Fade off Down"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(down_sequence_active) = false;
                  id(effect_finished) = false;
                  id(last_pir_cleared_time) = 0;
                  id(last_trigger_time) = 0;
              - delay: 
                  6s
              - light.turn_off:
                  id: stair_light

# Automation for special scenarios
#The interval component checks every second if:
#    The LED is on
#    60 seconds have passed since last trigger
#    Both PIRs are off
interval:
  - interval: 10s
    then:
      - lambda: |-
            ESP_LOGD("Global Variables", "PIR Sensor (Lower) before condition");
            ESP_LOGD("Global Variables", "light_state: %i", id(light_state));
            ESP_LOGD("Global Variables", "up_sequence_active: %s", id(up_sequence_active) ? "true" : "false");
            ESP_LOGD("Global Variables", "down_sequence_active: %s", id(down_sequence_active) ? "true" : "false");
            ESP_LOGD("Global Variables", "last_pir: %i", id(last_pir));
            ESP_LOGD("Global Variables", "last_trigger_time: %li", id(last_trigger_time));
            ESP_LOGD("Global Variables", "last_pir_cleared_time: %li", id(last_pir_cleared_time));
            ESP_LOGD("Global Variables", "effect_finished: %s", id(effect_finished) ? "true" : "false");
      # Conditional debug logging 
      #### need to test
      #- if:
      #    condition:
      #      lambda: 'return ESPHOME_LOG_LEVEL >= ESPHOME_LOG_LEVEL_DEBUG;'
      #    then:
      #      - lambda: |-
      #            //ESP_LOGD("Global Variables", "PIR Sensor (Lower) before condition");
      #            ESP_LOGD("Global Variables", "light_state: %i", id(light_state));
      #            ESP_LOGD("Global Variables", "up_sequence_active: %s", id(up_sequence_active) ? "true" : "false");
      #            ESP_LOGD("Global Variables", "down_sequence_active: %s", id(down_sequence_active) ? "true" : "false");
      #            ESP_LOGD("Global Variables", "last_pir: %i", id(last_pir));
      #            ESP_LOGD("Global Variables", "last_trigger_time: %li", id(last_trigger_time));
      #            ESP_LOGD("Global Variables", "last_pir_cleared_time: %li", id(last_pir_cleared_time));
      #            ESP_LOGD("Global Variables", "effect_finished: %s", id(effect_finished) ? "true" : "false");
      # Scenario 1: 1-minute timeout
      - if:
          condition:
            and:
              - light.is_on: stair_light
              - lambda: 'return (millis() - id(last_trigger_time)) > 60000 && id(effect_finished);'
              - binary_sensor.is_off: upper_pir_sensor
              - binary_sensor.is_off: lower_pir_sensor
              #- lambda: 'return !id(up_sequence_active) && !id(down_sequence_active);'  # Only if no sequence is active
          then:
            - light.turn_off: stair_light
            - lambda: |
                id(up_sequence_active) = false;
                id(down_sequence_active) = false;
                id(effect_finished) = false;
                id(light_state) = 0;
                id(last_trigger_time) = 0;
                id(last_pir) = 0;
      # Recovery from stuck state
      - if:
          condition:
            and:
              - light.is_on: stair_light
              - lambda: 'return !id(up_sequence_active) && !id(down_sequence_active) && id(effect_finished) && (millis() - id(last_trigger_time)) > 60000;'
              - binary_sensor.is_off: upper_pir_sensor
              - binary_sensor.is_off: lower_pir_sensor
          then:
            - light.turn_off: stair_light
            - lambda: |
                id(light_state) = 0;
                id(last_trigger_time) = 0;
                id(last_pir) = 0;
                ESP_LOGD("interval", "Recovered from stuck state");
      # Scenario 2: Same PIR after 25s clear (Lower PIR)
#      - if:
#          condition:
#            and:
#              - lambda: 'return (millis() - id(last_pir_cleared_time)) > 10000;'
#              - lambda: 'return id(last_pir) == 1 && id(lower_pir_sensor)->state;'
#          then:
#            - light.turn_on:
#                id: stair_light
#                effect: "Fade off DOWN"
#                # changed to from true to false
#            - lambda: 'id(up_sequence_active) = false;'
      # Scenario 2: Same PIR after 25s clear (Upper PIR)
#      - if:
#          condition:
#            and:
#              - lambda: 'return (millis() - id(last_pir_cleared_time)) > 10000;'
#              - lambda: 'return id(last_pir) == 2 && id(upper_pir_sensor)->state;'
#          then:
#            - light.turn_on:
#                id: stair_light
#                effect: "Fade off UP"
                # changed to from true to false                
#            - lambda: 'id(down_sequence_active) = false;'

wled:

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO4
    num_leds: 110
    name: "Stair Light"
    id: "stair_light"
    restore_mode: ALWAYS_OFF
    effects:
      - wled:
          # port: 21324
          # blank_on_start: True
          # sync_group_mask: 0
      - addressable_lambda:
          name: "Fade on DOWN"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            //initializes the progress variable to 0. This variable is intended to track which LED is being lit.
            static auto TAG = "Fade on DOWN";
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            // initial_run resets the progress to 0.
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              it.all() = Color::BLACK;
              ESP_LOGD("effect", "Fade on DOWN started");
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              progress++;
              it[it.size() - progress] = mColor;
              effect_complete = false;
              //ESP_LOGD("effect", "Progress: %d", progress);
            } else {
              effect_complete = true;
            }
            id(effect_finished) = effect_complete;


      - addressable_lambda:
          name: "Fade off DOWN"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static auto TAG = "Fade off DOWN";
            static ESPHSVColor mBlack = ESPHSVColor(255, 255, 0);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              //it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              progress++;
              it[it.size() - progress] = mBlack;
              effect_complete = false;
            } else {
              effect_complete = true;
            }
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Fade on UP"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static auto TAG = "Fade on UP";
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              it[progress] = mColor;
              progress++;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            };
            // Expose the completion status to global
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Fade off UP"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static auto TAG = "Fade off UP";
            static ESPHSVColor mBlack = ESPHSVColor(255, 255, 0);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              // it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              it[progress] = mBlack;
              progress++;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            }
            // Expose the completion status to global
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Group Fade on UP"
          update_interval: 50ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = it.size() - progress - i - 1;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              progress += GROUP_SIZE;
            }

      - addressable_lambda:
          name: "Group Fade off UP"
          update_interval: 500ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static ESPHSVColor mColor = ESPHSVColor(255, 255, 0);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = it.size() - progress - i - 1;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              progress += GROUP_SIZE;
            }

      - addressable_lambda:
          name: "Group Fade on Down"
          update_interval: 50ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static const uint16_t GAP_SIZE = 5;
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = progress + i;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              //progress += GROUP_SIZE + GAP_SIZE;
              progress += GROUP_SIZE;
            }

      - addressable_lambda:
          name: "Group Fade off Down"
          update_interval: 50ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static const uint16_t GAP_SIZE = 5;
            static ESPHSVColor mColor = ESPHSVColor(255, 255, 0);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = progress + i;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              //progress += GROUP_SIZE + GAP_SIZE;
              progress += GROUP_SIZE;
              //progress -= GROUP_SIZE; // Decrement progress
            }

      - addressable_lambda:
          name: "Addressable Fade"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static uint16_t progress = 0;
            static ESPHSVColor targetColor;
            static bool fadeUp;

            if (initial_run) {
              progress = 0;
              targetColor = ESPHSVColor(255, 0, 250);
              fadeUp = true;
              return;
            }

            if (id(down_sequence_active)) {
              targetColor = ESPHSVColor(255, 0, 250);
              fadeUp = true;
            } else if (id(up_sequence_active)) {
              targetColor = ESPHSVColor(255, 255, 0);
              fadeUp = false;
            }

            if (fadeUp) {
              if (progress < it.size()) {
                it[it.size() - progress - 1] = targetColor;
                progress++;
              }
            } else {
              if (progress < it.size()) {
                it[progress] = targetColor;
                progress++;
              }
            }
      - addressable_color_wipe:
          name: forward wipe
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 5
              gradient: true
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_color_wipe:
          name: rev wipe
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 5
              gradient: true
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: true
      - addressable_rainbow:
          name: Rainbow Effect With Custom Values
          speed: 10
          width: 50
      - pulse:
          name: "Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
