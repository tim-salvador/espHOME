esphome:
  name: stairwell-effects
  friendly_name: stairwell_effects
  on_boot:
    priority: -10
    then:
      - light.turn_off: stair_light

esp8266:
  board: esp01_1m

# Enable logging
logger:
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Stairwell-Effects"
    password: !secret sw_effect_ap_pass

captive_portal:

api:

ota:
  - platform: esphome
    password: !secret sw_effect_ota

web_server:
  version: 3


globals:
  - id: light_state
    type: int
    restore_value: no
    initial_value: '0' # 0 = off, 1 = low to high, 2 = high to low
  - id: cooldown_active
    type: bool
    initial_value: 'false'
  - id: upper_pir_time
    type: long
    initial_value: '0'
  - id: lower_pir_time
    type: long
    initial_value: '0'
  - id: up_sequence_active
    type: bool
    initial_value: 'false'
  - id: down_sequence_active
    type: bool
    initial_value: 'false'
  - id: last_pir
    type: int
    initial_value: '0'  # 0 = none, 1 = lower PIR, 2 = upper PIR
  - id: progress
    type: int
    restore_value: no
    initial_value: '0'

  #- id: led_color_on
  #  type: esp_color::ESPHSVColor
  #  restore_value: yes
  #  initial_value: 'esphsv(255, 0, 250)' # Default color
  #- id: led_color_off
  #  type: esp_color::ESPHSVColor
  #  restore_value: yes
  #  initial_value: 'esphsv(255, 255, 0)' # Default color
  - id: led_group_size
    type: int
    restore_value: yes
    initial_value: '10' # Default group size
  - id: led_gap_size
    type: int
    restore_value: yes
    initial_value: '5' # Default gap size
  - id: timeout_active
    type: bool
    restore_value: no
    initial_value: 'false'

number:
  - platform: template
    name: "LED Group Size"
    id: led_group_size_number
    min_value: 1
    max_value: 50 # Adjust as needed
    step: 1
    restore_value: yes
    optimistic: true
    set_action:
      - lambda: 'id(led_group_size) = x;'

  - platform: template
    name: "LED Gap Size"
    id: led_gap_size_number
    min_value: 0
    max_value: 20 # Adjust as needed
    step: 1
    restore_value: yes
    optimistic: true
    set_action:
      - lambda: 'id(led_gap_size) = x;'



binary_sensor:
  - platform: gpio
    pin:
      number: 14
      #mode: INPUT_PULLUP
      #inverted: true 
    name: "PIR Sensor (Upper)"
    id: upper_pir_sensor
    device_class: motion
    ### This works one way right now.  the logic is from upper to lower.  now need to do the reverse.  
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(up_sequence_active) == false;'
            then:
      #        - light.turn_on:
      #            id: stair_light
              - light.turn_on:
                  id: stair_light
                  effect: "Fade on DOWN"
              - lambda: 'id(down_sequence_active) = true;'

    ### This works one way right now.  the logic is from upper to lower.  now need to do the reverse.  
    on_release:
      then:
        - if:
            condition:
              lambda: 'return (id(up_sequence_active) == true && id(down_sequence_active) == false);'
            then:
              - wait_until:
                  condition:
                    binary_sensor.is_off: upper_pir_sensor
                  timeout: 30s
              - light.turn_on:
                  id: stair_light
                  effect: "Fade off UP"
              - delay: 10s
              - lambda: 'id(up_sequence_active) = false;'


#    on_press:
#      then:
#        # Record the time of the PIR trigger
#        - lambda: |-
#            id(upper_pir_time) = millis();
#            id(last_pir) = 2;  
#            // Mark this as the last PIR triggered
#      then:
#        - if:
#            condition:
#              lambda: return id(light_state) == 0;
#            then:
              
#              - logger.log:
#                  format: "Upper PIR: Condition met, light_state: %d"
#                  args:
#                    - id(light_state)
#              - light.turn_on:
#                  id: stair_light
#                  effect: "Fade on DOWN"
#              - lambda: 'id(light_state) = 2;'
#            else:
#              - lambda: 'id(light_state) = 1;'
#              - light.turn_on:
#                  id: stair_light
#                  effect: "Fade off UP"
#              - logger.log:
#                  format: "Upper PIR: Condition not met, light_state: %d"
#                  args:
#                    - id(light_state)
#    on_release:
#      - light.turn_on:
#          id: stair_light
#          effect: "Fade off DOWN"
#      - delay: 2s  # Corrected indentation
#      - lambda: 'id(light_state) = 0;'


    ### Havn't tested this yet  
#    on_release:
#      then:
#        - if:
#3            condition:
#              lambda: 'return id(up_sequence_active) == true && id(down_sequence_active) == false;'
#            then:
#              - wait_until:
#                  condition:
#                    binary_sensor.is_off: upper_pir_sensor
#                  timeout: 20s
#              - light.turn_on:
#                  id: stair_light
#                  effect: "Fade off Up"
#              - delay: 5s
#              - lambda: 'id(up_sequence_active) = false;'


  - platform: gpio
    pin:
      number: 12
      #mode: INPUT_PULLUP
      #inverted: true # used due to gpio pulling high on boot
    name: "PIR Sensor (Lower)"
    id: lower_pir_sensor
    device_class: motion
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(down_sequence_active) == false;'
            then:
      #        - light.turn_on:
      #            id: stair_light
              - light.turn_on:
                  id: stair_light
                  effect: "Fade on UP"
              - lambda: 'id(up_sequence_active) = true;'
#    on_press:
#      then:
#        - light.turn_on:
#            id: stair_light
#        - light.turn_on:
#            id: stair_light
#            effect: "Fade on UP"
#        - lambda: 'id(up_sequence_active) = true;'
    ### This works one way right now.  the logic is from upper to lower.  now need to do the reverse.  
    on_release:
      then:
        - if:
            condition:
              lambda: 'return (id(down_sequence_active) == true && id(up_sequence_active) == false);'
            then:
              - wait_until:
                  condition:
                    binary_sensor.is_off: lower_pir_sensor
                  timeout: 30s
              - light.turn_on:
                  id: stair_light
                  effect: "Fade off Down"
              - delay: 10s
              - lambda: 'id(down_sequence_active) = false;'
#              - light.turn_off:
#                  id: stair_light



#    on_press:
#      then:
#        - lambda: 'id(upper_pir_time) = millis();'
#        - if:
#            condition:
#              lambda: return id(light_state) == 0;
#            then:
#              - logger.log:
#                  format: "Lower PIR: Condition met, light_state: %d"
#                  args:
#                    - id(light_state)
#              - light.turn_on:
#                  id: stair_light
#                  effect: "Fade on UP"
#              - lambda: 'id(light_state) = 1;'
#            else:
#              - lambda: 'id(light_state) = 2;'
#              - light.turn_on:
#                  id: stair_light
#                  effect: "Fade off DOWN"
#              - logger.log:
#                  format: "Lower PIR: Condition not met, light_state: %d" # corrected line
#                  args:
#                    - id(light_state)
#    on_release:
#      then:
#        - lambda: |-
#            if (id(upper_pir_time) > id(lower_pir_time)) {
#              // Upper PIR triggered more recently
#            } else {
#              // Lower PIR triggered more recently
#            }
#    on_release:
#      - light.turn_on:
#          id: stair_light
#          effect: "Fade off DOWN"
#      - delay: 2s  # Corrected indentation
#      - lambda: 'id(light_state) = 0;'


wled:


light:
#  - platform: monochromatic
#    name: "LED Color Control"
#    id: led_color_light
#    restore_value: yes
#    effects:
#      - lambda: |-
#          return ESPColor(id(led_color));
#    on_turn_on:
#      - lambda: |-
#          id(led_color) = x.get_hsv();


  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO4
    num_leds: 110
    name: "Stair Light"
    id: "stair_light"
    restore_mode: ALWAYS_OFF
    effects:
      - wled:
          # port: 21324
          # blank_on_start: True
          # sync_group_mask: 0
      - automation:
          name: "Custom Automation Effect"
          sequence:
            - light.addressable_set:
                id: stair_light
                red: 100%
                green: 100%
                blue: 100%
            - delay: 100ms
            - light.addressable_set:
                id: stair_light
                range_from: 0
                range_to: 20
                red: 100%
                green: 0%
                blue: 0%
      - addressable_lambda:
          name: "bonus2"
          update_interval: 16ms
          lambda: |-
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
      - addressable_lambda:
          name: "bonus"
          update_interval: 15ms
          lambda: |-
            // it.size() - Number of LEDs
            // it[num] - Access the LED at index num.
            // Set the LED at num to the given r, g, b values
            // it[num] = Color(r, g, b);
            // Get the color at index num (Color instance)
            // it[num].get();

            // Example: Simple color wipe
            for (int i = it.size() - 1; i > 0; i--) {
              it[i] = it[i - 1].get();
            }
            it[0] = Color::random_color();

            // Bonus: use .range() and .all() to set many LEDs without having to write a loop.
            //it.range(0, 50) = Color::BLACK;
            //it.all().fade_to_black(10);
      - lambda:
          name: unknown
          update_interval: 1s
          lambda: |-
            static int state = 0;
            auto call = id(stair_light).turn_on();
            // Transition of 1000ms = 1s
            call.set_transition_length(1000);
            if (state == 0) {
              call.set_rgb(1.0, 1.0, 1.0);
            } else if (state == 1) {
              call.set_rgb(1.0, 0.0, 1.0);
            } else if (state == 2) {
              call.set_rgb(0.0, 0.0, 1.0);
            } else {
              call.set_rgb(1.0, 0.0, 0.0);
            }
            call.perform();
            state += 1;
            if (state == 4)
              state = 0;


      - addressable_lambda:
          name: "Fade on UP"
          update_interval: 15ms
          lambda: |-
            //initializes the progress variable to 0. This variable is intended to track which LED is being lit.
            static auto TAG = "Fade on UP";
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            // initial_run resets the progress to 0.
            if (initial_run) {
              progress = 0;
              //it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
            //if (progress == 0) {
              //it[it.size() - 1] = mBlack;  // Light the first LED
              //progress = 1;  // Start progress
            //}
            // This condition checks if the current progress is within the bounds of the LED strip.
            //  incremented to 1.
            if (progress < it.size()) {
              progress++;
              it[it.size() - progress] = mColor;
            };

      - addressable_lambda:
          name: "Fade off UP"
          update_interval: 15ms
          lambda: |-
            static auto TAG = "Fade off UP";
            static ESPHSVColor mBlack = ESPHSVColor(255, 255, 0);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              //it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
            //if (progress == 0) {
              //it[it.size() - 1] = mBlack;  // Light the first LED
              //progress = 1;  // Start progress
            //}
            if (progress < it.size()) {
              progress++;
              it[it.size() - progress] = mBlack;
            };

      - addressable_lambda:
          name: "Fade on DOWN"
          update_interval: 15ms
          lambda: |-
            static auto TAG = "Fade on Down";
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
            //if (progress == 0) {
              // Reset progress when the effect starts
              //progress = 1;
              //it[progress] = mColor;
            //}
            if (progress < it.size()) {
              it[progress] = mColor;
              progress++;
            };
      - addressable_lambda:
          name: "Fade off DOWN"
          update_interval: 15ms
          lambda: |-
            static auto TAG = "Fade off Down";
            static ESPHSVColor mBlack = ESPHSVColor(255, 255, 0);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              // it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
            ESP_LOGD("lambda", "progress: %d", progress);
            //if (progress == 0) {
              // Reset progress when the effect starts
              //progress = 1;
              //it[progress] = mBlack;
            //}
            if (progress < it.size()) {
              it[progress] = mBlack;
              progress++;
            };


      - addressable_lambda:
          name: "Group Fade on UP"
          update_interval: 50ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            static uint16_t progress = 0;

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = it.size() - progress - i - 1;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              progress += GROUP_SIZE;
            }

      - addressable_lambda:
          name: "Group Fade off UP"
          update_interval: 500ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static ESPHSVColor mColor = ESPHSVColor(255, 255, 0);
            static uint16_t progress = 0;

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = it.size() - progress - i - 1;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              progress += GROUP_SIZE;
            }

      - addressable_lambda:
          name: "Group Fade on Down"
          update_interval: 50ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static const uint16_t GAP_SIZE = 5;
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            static uint16_t progress = 0;

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = progress + i;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              //progress += GROUP_SIZE + GAP_SIZE;
              progress += GROUP_SIZE;
            }

      - addressable_lambda:
          name: "Group Fade off Down"
          update_interval: 50ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 10;
            static const uint16_t GAP_SIZE = 5;
            static ESPHSVColor mColor = ESPHSVColor(255, 255, 0);
            static uint16_t progress = 0;

            if (initial_run) {
              progress = 0;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = progress + i;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              //progress += GROUP_SIZE + GAP_SIZE;
              progress += GROUP_SIZE;
              //progress -= GROUP_SIZE; // Decrement progress
            }

      - addressable_lambda:
          name: "Addressable Fade"
          update_interval: 15ms
          lambda: |-
            static uint16_t progress = 0;
            static ESPHSVColor targetColor;
            static bool fadeUp;

            if (initial_run) {
              progress = 0;
              targetColor = ESPHSVColor(255, 0, 250);
              fadeUp = true;
              return;
            }

            if (id(down_sequence_active)) {
              targetColor = ESPHSVColor(255, 0, 250);
              fadeUp = true;
            } else if (id(up_sequence_active)) {
              targetColor = ESPHSVColor(255, 255, 0);
              fadeUp = false;
            }

            if (fadeUp) {
              if (progress < it.size()) {
                it[it.size() - progress - 1] = targetColor;
                progress++;
              }
            } else {
              if (progress < it.size()) {
                it[progress] = targetColor;
                progress++;
              }
            }

      - addressable_scan:
          name: Scan Effect With Custom Values
          move_interval: 100ms
          scan_width: 1
      - random:
          name: Random Effect With Custom Values
          transition_length: 5s
          update_interval: 7s
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s
      - pulse:
          name: "Asymmetrical Pulse"
          transition_length:
            on_length: 1s
            off_length: 500ms
          update_interval: 1.5s
      - addressable_scan:
          name: "round2"
          move_interval: 100ms
          scan_width: 10
      - addressable_color_wipe:
          name: forward wipe
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 5
              gradient: true
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_color_wipe:
          name: rev wipe
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 5
              gradient: true
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: true
      - addressable_rainbow:
          name: Rainbow Effect With Custom Values
          speed: 10
          width: 50



















