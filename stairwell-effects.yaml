esphome:
  name: stairwell-effects
  friendly_name: stairwell_effects
  on_boot:
    priority: -10
    then:
      - light.turn_off: stair_light
      - lambda: |
          id(system_state) = 0;
          id(up_sequence_active) = false;
          id(down_sequence_active) = false;
          id(effect_finished) = false;
          id(last_trigger_time) = 0;
          id(last_pir) = 0;

esp8266:
  board: esp01_1m

# Enable logging
logger:
  #level: DEBUG
  level: ERROR
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Stairwell-Effects"
    password: !secret sw_effect_ap_pass

captive_portal:

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret sw_effect_ota

web_server:
  version: 3


globals:
  ## need to clean up the globals
  - id: light_state
    type: int
    restore_value: no
    initial_value: '0' # 0 = off, 1 = low to high, 2 = high to low
# used to track direction
  - id: up_sequence_active
    type: bool
    initial_value: 'false'
  - id: down_sequence_active
    type: bool
    initial_value: 'false'
  - id: last_pir
    type: int
    initial_value: '0'  # 0 = none, 1 = lower PIR, 2 = upper PIR
  - id: progress
    type: int
    restore_value: no
    initial_value: '0'

# Used to track last triggered 
  - id: last_trigger_time
    type: long
    initial_value: '0'
  - id: last_pir_cleared_time
    type: long
    initial_value: '0'
  - id: effect_finished  # New global to track effect completion
    type: bool
    initial_value: 'false'
# Added globals for Easter egg
  - id: disco_trigger_count
    type: int
    initial_value: '0'
  - id: last_disco_trigger_time
    type: long
    initial_value: '0'
  - id: disco_mode_active
    type: bool
    initial_value: 'false'
  # Easter Egg 2
  - id: knock_count
    type: int
    initial_value: '0'
  - id: last_knock_time
    type: long
    initial_value: '0'
  # Easter Egg 3
  - id: both_pir_start_time
    type: long
    initial_value: '0'
  # used for unification of fade actions
  - id: fade_direction_up
    type: bool
    initial_value: 'true'  # true = up, false = down
  - id: fade_on
    type: bool
    initial_value: 'true'  # true = on (white), false = off (black)
  - id: led_group_size
    type: int
    restore_value: yes
    initial_value: '10' # Default group size - Number of LEDs to light at a time
  - id: led_gap_size
    type: int
    restore_value: yes
    initial_value: '5' # Default gap size

## Would like to add a system status that encorporates multiple globals.  for example
  - id: system_state
    type: int
    initial_value: '0'  # 0 = idle, 1 = up_active, 2 = down_active, 3 = cooling_down
## From the i could Update logic to use system_state instead of multiple booleans:
## Example
#- lambda: |
#    if (id(system_state) == 0) {  // Idle
#      id(last_trigger_time) = millis();
#      id(system_state) = 1;       // Up active
#    }

# HA tracking
sensor:
  - platform: template
    name: "System State"
    id: system_state_sensor
    update_interval: 1s
    lambda: 'return id(system_state);'
    unit_of_measurement: ""
    icon: "mdi:state-machine"
  - platform: template
    name: "Last PIR Triggered"
    id: last_pir_sensor
    update_interval: 1s
    lambda: 'return id(last_pir);'
    unit_of_measurement: ""
    icon: "mdi:motion-sensor"
  - platform: template
    name: "Effect Finished"
    id: effect_finished_sensor
    update_interval: 1s
    lambda: 'return id(effect_finished) ? 1 : 0;'
    unit_of_measurement: ""
    icon: "mdi:check-circle"
  - platform: template
    name: "Disco Mode Active"
    id: disco_mode_sensor
    update_interval: 1s
    lambda: 'return id(disco_mode_active) ? 1 : 0;'
    unit_of_measurement: ""
    icon: "mdi:disco"

## Ambient Light Sensor
#sensor:
#  - platform: bh1750
#    name: "Ambient Light"
#    id: ambient_light
#    update_interval: 60s
#light:
#  - platform: neopixelbus
#    ...
#    on_state:
#      then:
#        - lambda: |
#            if (id(ambient_light).state < 50) {  // Lux threshold
#              id(stair_light).turn_on().set_brightness(0.8);
#            } else {
#              id(stair_light).turn_on().set_brightness(0.4);
#            }

number:
  # not needed now but might incorporate for adding gaps
  #- platform: template
  #  name: "LED Gap Size"
  #  id: led_gap_size_number
  #  min_value: 0
  #  max_value: 20 # Adjust as needed
  #  step: 1
  #  restore_value: yes
  #  optimistic: true
  #  set_action:
  #    - lambda: 'id(led_gap_size) = x;'
  # used for unification of fade actions
  - platform: template
    name: "LED Group Size"
    id: led_group_size_number
    min_value: 1
    max_value: 20  # Adjust as needed
    step: 1
    restore_value: yes
    optimistic: true
    set_action:
      - lambda: 'id(led_group_size) = x;'

binary_sensor:
  - platform: gpio
    pin:
      number: 12
      #mode: INPUT_PULLUP
      #inverted: true 
    name: "PIR Sensor (Upper)"
    id: upper_pir_sensor
    filters:
      - delayed_on: 100ms  # Debounce on
      - delayed_off: 200ms # Debounce off    
    device_class: motion
    on_press:
      then:
        # Easter egg trigger check for disco mode
        # Trigger: Activate both PIR sensors (upper and lower) simultaneously three times within a 5-second window.
        # Effect: "Disco Mode" activates, creating a colorful, rotating rainbow pattern across all LEDs.
        # Duration: The effect runs for 10 seconds before automatically turning off and resetting the system.
        # Visual: LEDs cycle through hues with a smooth rainbow effect, shifting colors every 200ms.
        - lambda: |
            if (id(lower_pir_sensor).state) {  // Both PIRs active
              if (millis() - id(last_disco_trigger_time) < 5000) {
                id(disco_trigger_count)++;
              } else {
                id(disco_trigger_count) = 1;  // Reset count if too much time passed
              }
              id(last_disco_trigger_time) = millis();
              if (id(disco_trigger_count) >= 3 && !id(disco_mode_active)) {
                id(disco_mode_active) = true;
                id(stair_light).turn_on().set_effect("Disco Mode");
              }
            }

        ## Trigger to test unified fade 
        - if:
            condition:
              lambda: 'return ((!id(up_sequence_active) && !id(down_sequence_active)) || (!id(up_sequence_active) && id(light_state) == 0));'
            then:
              - lambda: |
                  id(fade_direction_up) = false;  // Down
                  id(fade_on) = true;             // On (white)
              - light.turn_on:
                  id: stair_light
                  effect: "Fade Control"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(down_sequence_active) = true;
                  id(effect_finished) = false;
                  id(last_trigger_time) = millis();
                  id(last_pir) = 2;
                  id(light_state) = 1;

        ## Default Action for Going Down
        #- if:
        #    condition:
        #       lambda: 'return ((!id(up_sequence_active) && !id(down_sequence_active)) || (!id(up_sequence_active) && id(light_state) == 0));'  # Only trigger if no sequence is active
        #    then:
        #      - light.turn_on:
        #          id: stair_light
        #          effect: "Group Fade on DOWN"
        #      - wait_until:
        #          condition:
        #            lambda: 'return id(effect_finished);'
        #      - lambda: |
        #          id(down_sequence_active) = true;
        #          id(effect_finished) = false;
        #          id(last_trigger_time) = millis();
        #          id(last_pir) = 2;
        #          id(light_state) = 1;
          
        ## Default Action for turning halfway and going back Up 
        - if:
            condition:
              lambda: 'return (id(effect_finished) && id(last_pir) == 2 && id(down_sequence_active) && id(light_state) == 1 );'
              #lambda: 'return (id(last_trigger_time) > 4000 && id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
              #lambda: 'return (id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
            then:
              - light.turn_on:
                  id: stair_light
                  effect: "Group Fade off UP"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(down_sequence_active) = false;
                  id(effect_finished) = false;
                  id(last_trigger_time) = 0;
                  id(last_pir) = 0;
                  id(light_state) = 0;


    on_release:
      then:
        - lambda: 'id(last_pir_cleared_time) = millis();'
        ## Default Action for turning off the lights going up
        - if:
            condition:
              lambda: 'return (id(up_sequence_active) == true && id(down_sequence_active) == false);'
            then:
              - wait_until:
                  condition:
                    binary_sensor.is_off: upper_pir_sensor
                  timeout: 30s
              - light.turn_on:
                  id: stair_light
                  effect: "Group Fade off UP"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(up_sequence_active) = false;
                  id(effect_finished) = false;
                  id(last_pir_cleared_time) = 0;
                  id(last_trigger_time) = 0;
                  id(system_state) = 1;
              - delay: 
                  6s
              - light.turn_off:
                  id: stair_light              


  - platform: gpio
    pin:
      number: 14
      #mode: INPUT_PULLUP
      #inverted: true 
    name: "PIR Sensor (Lower)"
    id: lower_pir_sensor
    device_class: motion
    filters:
      - delayed_on: 100ms  # Debounce on
      - delayed_off: 200ms # Debounce off    
    on_press:
        then:
          # Easter egg trigger check
          - lambda: |
              if (id(upper_pir_sensor).state) {  // Both PIRs active
                if (millis() - id(last_disco_trigger_time) < 5000) {
                  id(disco_trigger_count)++;
                } else {
                  id(disco_trigger_count) = 1;  // Reset count if too much time passed
                }
                id(last_disco_trigger_time) = millis();
                if (id(disco_trigger_count) >= 3 && !id(disco_mode_active)) {
                  id(disco_mode_active) = true;
                  id(stair_light).turn_on().set_effect("Disco Mode");
                }
              }
          # "Secret Knock" Easter Egg
          # Trigger: Rapidly trigger the lower PIR sensor 5 times within 3 seconds (like a secret knock).
          # Effect: Activates a "Fire Flicker" effect that mimics a warm, flickering candlelight glow for 15 seconds.
          # Purpose: Adds a cozy, mysterious ambiance, perfect for a dramatic stairwell entrance.
          - lambda: |
              if (millis() - id(last_knock_time) < 3000) {
                id(knock_count)++;
              } else {
                id(knock_count) = 1;  // Reset if too much time passed
              }
              id(last_knock_time) = millis();
              if (id(knock_count) >= 5) {
                id(stair_light).turn_on().set_effect("Fire Flicker");
                id(knock_count) = 0;  // Reset after triggering
              }
          #- lambda: |-
          #      ESP_LOGD("Global Variables", "PIR Sensor (Lower) before condition");
          #      ESP_LOGD("Global Variables", "light_state: %i", id(light_state));
          #      ESP_LOGD("Global Variables", "up_sequence_active: %s", id(up_sequence_active) ? "true" : "false");
          #      ESP_LOGD("Global Variables", "down_sequence_active: %s", id(down_sequence_active) ? "true" : "false");
          #      ESP_LOGD("Global Variables", "last_pir: %i", id(last_pir));
          #      ESP_LOGD("Global Variables", "last_trigger_time: %li", id(last_trigger_time));
          #      ESP_LOGD("Global Variables", "last_pir_cleared_time: %li", id(last_pir_cleared_time));
          #      ESP_LOGD("Global Variables", "effect_finished: %s", id(effect_finished) ? "true" : "false");
          
          ## Trigger to test unified fade 
          - if:
              condition:
                and:
                  - lambda: 'return ((!id(up_sequence_active) && !id(down_sequence_active)) || (!id(down_sequence_active) && id(light_state) == 0));'
              then:
                - lambda: |
                    id(fade_direction_up) = true;  // Up
                    id(fade_on) = true;            // On (white)
                - light.turn_on:
                    id: stair_light
                    effect: "Fade Control"
                - wait_until:
                    condition:
                      lambda: 'return id(effect_finished);'
                - lambda: |
                    id(up_sequence_active) = true;
                    id(effect_finished) = false;
                    id(last_trigger_time) = millis();
                    id(last_pir) = 1;
                    id(light_state) = 1;
          
          ## Default Action for Going Up
          #- if:
          #    condition:
          #      and:
          #        - lambda: 'return ((!id(up_sequence_active) && !id(down_sequence_active)) || (!id(down_sequence_active) && id(light_state) == 0));'
          #    then:
          #      - light.turn_on:
          #          id: stair_light
          #          effect: "Group Fade on UP"
          #      - wait_until:
          #          condition:
          #            lambda: 'return id(effect_finished);'
          #      - lambda: |
          #          id(up_sequence_active) = true;
          #          id(effect_finished) = false;
          #          id(last_trigger_time) = millis();
          #          id(last_pir) = 1;
          #          id(light_state) = 1;

          ## Default Action for turning halfway and going back Down 
          - if:
              condition:
                and:
                  - lambda: 'return (id(effect_finished) && id(last_pir) == 1 && id(up_sequence_active) && id(light_state) == 1 );'
                  #- lambda: 'return id(last_pir) == 1 && (millis() - id(last_trigger_time)) < 5000;'
                  #- binary_sensor.is_on: lower_pir_sensor
                  # - lambda: 'return (id(last_trigger_time) > 4000 && id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
                  # - lambda: 'return (id(last_pir) == 1 && id(up_sequence_active) && !id(lower_pir_sensor).state);'
                  # - lambda: 'return (millis() - id(last_trigger_time)) > 500;'  # 500ms cooldown
              then:
                - light.turn_on:
                    id: stair_light
                    effect: "Group Fade off Down"
                - wait_until:
                    condition:
                      lambda: 'return id(effect_finished);'
                - lambda: |
                    id(up_sequence_active) = false;
                    id(effect_finished) = false;
                    id(last_trigger_time) = 0;
                    id(last_pir) = 0;
                    id(light_state) = 0;

    on_release:
      then:
        - lambda: 'id(last_pir_cleared_time) = millis();'
        ## Default Action for turning off the lights going Down
        - if:
            condition:
              lambda: 'return (id(down_sequence_active) == true && id(up_sequence_active) == false);'
            then:
              - wait_until:
                  condition:
                    binary_sensor.is_off: lower_pir_sensor
                  timeout: 30s
              - light.turn_on:
                  id: stair_light
                  effect: "Group Fade off Down"
              - wait_until:
                  condition:
                    lambda: 'return id(effect_finished);'
              - lambda: |
                  id(down_sequence_active) = false;
                  id(effect_finished) = false;
                  id(last_pir_cleared_time) = 0;
                  id(last_trigger_time) = 0;
                  id(system_state) = 2;
              - delay: 
                  6s
              - light.turn_off:
                  id: stair_light

# Automation for special scenarios
#The interval component checks every second if:
#    The LED is on
#    60 seconds have passed since last trigger
#    Both PIRs are off
interval:
  # Moonlight Mode" Easter Egg
  # Trigger: Hold both PIR sensors active for 10 seconds (e.g., by standing still in range of both).
  # Effect: Activates a gentle, pulsing blue "Moonlight" effect for 30 seconds, simulating moonlight on the stairs.
  # Purpose: Creates a calming, nighttime aesthetic.
  - interval: 1s
    then:
      - if:
          condition:
            and:
              - binary_sensor.is_on: upper_pir_sensor
              - binary_sensor.is_on: lower_pir_sensor
          then:
            - lambda: |
                if (id(both_pir_start_time) == 0) {
                  id(both_pir_start_time) = millis();
                }
                if (millis() - id(both_pir_start_time) > 10000) {
                  id(stair_light).turn_on().set_effect("Moonlight");
                  id(both_pir_start_time) = 0;  // Reset after triggering
                }
          else:
            - lambda: 'id(both_pir_start_time) = 0;'
  - interval: 10s
    then:
      - lambda: |-
            ESP_LOGD("Global Variables", "PIR Sensor (Lower) before condition");
            ESP_LOGD("Global Variables", "light_state: %i", id(light_state));
            ESP_LOGD("Global Variables", "up_sequence_active: %s", id(up_sequence_active) ? "true" : "false");
            ESP_LOGD("Global Variables", "down_sequence_active: %s", id(down_sequence_active) ? "true" : "false");
            ESP_LOGD("Global Variables", "last_pir: %i", id(last_pir));
            ESP_LOGD("Global Variables", "last_trigger_time: %li", id(last_trigger_time));
            ESP_LOGD("Global Variables", "last_pir_cleared_time: %li", id(last_pir_cleared_time));
            ESP_LOGD("Global Variables", "effect_finished: %s", id(effect_finished) ? "true" : "false");
      # Conditional debug logging 
      #### need to test
      #- if:
      #    condition:
      #      lambda: 'return ESPHOME_LOG_LEVEL >= ESPHOME_LOG_LEVEL_DEBUG;'
      #    then:
      #      - lambda: |-
      #            //ESP_LOGD("Global Variables", "PIR Sensor (Lower) before condition");
      #            ESP_LOGD("Global Variables", "light_state: %i", id(light_state));
      #            ESP_LOGD("Global Variables", "up_sequence_active: %s", id(up_sequence_active) ? "true" : "false");
      #            ESP_LOGD("Global Variables", "down_sequence_active: %s", id(down_sequence_active) ? "true" : "false");
      #            ESP_LOGD("Global Variables", "last_pir: %i", id(last_pir));
      #            ESP_LOGD("Global Variables", "last_trigger_time: %li", id(last_trigger_time));
      #            ESP_LOGD("Global Variables", "last_pir_cleared_time: %li", id(last_pir_cleared_time));
      #            ESP_LOGD("Global Variables", "effect_finished: %s", id(effect_finished) ? "true" : "false");
      # Scenario 1: 1-minute timeout
      - if:
          condition:
            and:
              - light.is_on: stair_light
              - lambda: 'return (millis() - id(last_trigger_time)) > 60000 && id(effect_finished);'
              - binary_sensor.is_off: upper_pir_sensor
              - binary_sensor.is_off: lower_pir_sensor
              #- lambda: 'return !id(up_sequence_active) && !id(down_sequence_active);'  # Only if no sequence is active
          then:
            - light.turn_off: stair_light
            - lambda: |
                id(up_sequence_active) = false;
                id(down_sequence_active) = false;
                id(effect_finished) = false;
                id(light_state) = 0;
                id(last_trigger_time) = 0;
                id(last_pir) = 0;
                id(system_state) = 0;
      # Recovery from stuck state
      - if:
          condition:
            and:
              - light.is_on: stair_light
              - lambda: 'return !id(up_sequence_active) && !id(down_sequence_active) && id(effect_finished) && (millis() - id(last_trigger_time)) > 60000;'
              - binary_sensor.is_off: upper_pir_sensor
              - binary_sensor.is_off: lower_pir_sensor
          then:
            - light.turn_off: stair_light
            - lambda: |
                id(light_state) = 0;
                id(last_trigger_time) = 0;
                id(last_pir) = 0;
                ESP_LOGD("interval", "Recovered from stuck state");
#      # Scenario 2: Same PIR after 25s clear (Lower PIR)
#      - if:
#          condition:
#            and:
#              - lambda: 'return (millis() - id(last_pir_cleared_time)) > 10000;'
#              - lambda: 'return id(last_pir) == 1 && id(lower_pir_sensor)->state;'
#          then:
#            - light.turn_on:
#                id: stair_light
#                effect: "Fade off DOWN"
#                # changed to from true to false
#            - lambda: 'id(up_sequence_active) = false;'
      # Scenario 2: Same PIR after 25s clear (Upper PIR)
#      - if:
#          condition:
#            and:
#              - lambda: 'return (millis() - id(last_pir_cleared_time)) > 10000;'
#              - lambda: 'return id(last_pir) == 2 && id(upper_pir_sensor)->state;'
#          then:
#            - light.turn_on:
#                id: stair_light
#                effect: "Fade off UP"
                # changed to from true to false                
#            - lambda: 'id(down_sequence_active) = false;'

wled:

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO4
    num_leds: 110
    name: "Stair Light"
    id: "stair_light"
    restore_mode: ALWAYS_OFF
    effects:
      - wled:
          # port: 21324
          # blank_on_start: True
          # sync_group_mask: 0
      - addressable_lambda:
          name: "Fade on DOWN"
          #update_interval: 30ms #15ms is a nice number
          update_interval: 50ms
          lambda: |-
            //initializes the progress variable to 0. This variable is intended to track which LED is being lit.
            static auto TAG = "Fade on DOWN";
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            // initial_run resets the progress to 0.
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              it.all() = Color::BLACK;
              ESP_LOGD("effect", "Fade on DOWN started");
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              progress++;
              it[it.size() - progress] = mColor;
              effect_complete = false;
              //ESP_LOGD("effect", "Progress: %d", progress);
            } else {
              effect_complete = true;
            }
            id(effect_finished) = effect_complete;


      - addressable_lambda:
          name: "Fade off DOWN"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static auto TAG = "Fade off DOWN";
            static ESPHSVColor mBlack = ESPHSVColor(255, 255, 0);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              //it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              progress++;
              it[it.size() - progress] = mBlack;
              effect_complete = false;
            } else {
              effect_complete = true;
            }
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Fade on UP"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static auto TAG = "Fade on UP";
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              it[progress] = mColor;
              progress++;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            };
            // Expose the completion status to global
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Fade off UP"
          update_interval: 30ms #15ms is a nice number
          lambda: |-
            static auto TAG = "Fade off UP";
            static ESPHSVColor mBlack = ESPHSVColor(255, 255, 0);
            // Static variables keep their value even when
            // stopping and starting the effect again
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            // normal variables lose their value after each
            // execution - basically after each update_interval
            uint16_t changes = 0;

            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              progress = 0;
              effect_complete = false;  // Reset completion flag
              // it.all() = Color::BLACK;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }

            if (progress < it.size()) {
              it[progress] = mBlack;
              progress++;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            }
            // Expose the completion status to global
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Group Fade on DOWN"
          update_interval: 75ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 4;
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              effect_complete = false;
              it.all() = Color::BLACK;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = it.size() - progress - i - 1;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              progress += GROUP_SIZE;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            }
            // Expose the completion status to global
            id(effect_finished) = effect_complete;


      - addressable_lambda:
          name: "Group Fade off DOWN"
          update_interval: 75ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 4;
            static ESPHSVColor mColor = ESPHSVColor(255, 255, 0);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              effect_complete = false;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = it.size() - progress - i - 1;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              progress += GROUP_SIZE;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            }
            // Expose the completion status to global
            id(effect_finished) = effect_complete;

      - addressable_lambda:
          name: "Group Fade on UP"
          update_interval: 75ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 4;
            static const uint16_t GAP_SIZE = 5;
            static ESPHSVColor mColor = ESPHSVColor(255, 0, 250);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              effect_complete = false;
              it.all() = Color::BLACK;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = progress + i;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              //progress += GROUP_SIZE + GAP_SIZE;
              progress += GROUP_SIZE;
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            }
            // Expose the completion status to global
            id(effect_finished) = effect_complete;


      - addressable_lambda:
          name: "Group Fade off UP"
          update_interval: 75ms
          lambda: |-
            static const uint16_t GROUP_SIZE = 4;
            static const uint16_t GAP_SIZE = 5;
            static ESPHSVColor mColor = ESPHSVColor(255, 255, 0);
            static uint16_t progress = 0;
            static bool effect_complete = false;  // New flag to track completion

            if (initial_run) {
              progress = 0;
              effect_complete = false;
              return;
            }

            if (progress < it.size()) {
              for (uint16_t i = 0; i < GROUP_SIZE; i++) {
                uint16_t led_index = progress + i;
                if (led_index < it.size()) { // Ensure index is within bounds
                  it[led_index] = mColor;
                }
              }
              //progress += GROUP_SIZE + GAP_SIZE;
              progress += GROUP_SIZE;
              //progress -= GROUP_SIZE; // Decrement progress
              effect_complete = false;  // Effect still running
            } else {
              effect_complete = true;   // Effect has finished
            }
            // Expose the completion status to global
            id(effect_finished) = effect_complete;


      - addressable_color_wipe:
          name: forward wipe
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 5
              gradient: true
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_color_wipe:
          name: rev wipe
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 5
              gradient: true
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: true
      - addressable_rainbow:
          name: Rainbow Effect With Custom Values
          speed: 10
          width: 50
      - pulse:
          name: "Pulse"
          transition_length: 0.5s
          update_interval: 0.5s

      # New Easter egg effect 1
      - addressable_lambda:
          name: "Disco Mode"
          update_interval: 200ms
          lambda: |-
            static uint8_t hue = 0;
            static bool initial_run_complete = false;
            static uint32_t disco_start_time = 0;

            if (initial_run) {
              hue = 0;
              initial_run_complete = false;
              disco_start_time = millis();
              it.all() = ESPHSVColor(0, 255, 150);
              return;
            }

            // Run for 10 seconds then turn off
            if (millis() - disco_start_time > 10000) {
              it.all() = Color::BLACK;
              id(disco_mode_active) = false;
              id(disco_trigger_count) = 0;
              id(last_disco_trigger_time) = 0;
              id(up_sequence_active) = false;
              id(down_sequence_active) = false;
              id(light_state) = 0;
              id(stair_light).turn_off();
              return;
            }

            hue += 30;
            for (int i = 0; i < it.size(); i++) {
              uint8_t local_hue = (hue + (i * 10)) % 255;
              it[i] = ESPHSVColor(local_hue, 255, 150);
            }
      # New Easter egg effect 2
      - addressable_lambda:
          name: "Fire Flicker"
          update_interval: 100ms
          lambda: |-
            static uint32_t start_time = 0;
            if (initial_run) {
              start_time = millis();
              it.all() = ESPHSVColor(20, 255, 100);  // Warm orange base
              return;
            }
            if (millis() - start_time > 15000) {  // Run for 15 seconds
              it.all() = Color::BLACK;
              id(stair_light).turn_off();
              return;
            }
            for (int i = 0; i < it.size(); i++) {
              int flicker = random(0, 50);  // Random brightness variation
              it[i] = ESPHSVColor(20, 255, 100 + flicker);  // Warm flickering glow
            }
      # New Easter egg effect 3
      - addressable_lambda:
          name: "Moonlight"
          update_interval: 500ms
          lambda: |-
            static uint32_t start_time = 0;
            static uint8_t brightness = 50;
            static bool increasing = true;
            if (initial_run) {
              start_time = millis();
              brightness = 50;
              increasing = true;
              return;
            }
            if (millis() - start_time > 30000) {  // Run for 30 seconds
              it.all() = Color::BLACK;
              id(stair_light).turn_off();
              return;
            }
            if (increasing) {
              brightness += 10;
              if (brightness >= 150) increasing = false;
            } else {
              brightness -= 10;
              if (brightness <= 50) increasing = true;
            }
            it.all() = ESPHSVColor(220, 255, brightness);  // Soft blue pulsing
      # Description: A trail of light follows the direction of movement (up or down), with a gentle "breathing" pulse effect at the leading edge.
      # Use Case: Combines motion tracking with a soothing visual cue.
      - addressable_lambda:
          name: "Breathing Trail"
          update_interval: 100ms
          lambda: |-
            static int lead_pos = 0;
            static uint8_t breathe = 100;
            static bool increasing = true;
            static bool going_up = true;
            if (initial_run) {
              lead_pos = id(up_sequence_active) ? 0 : it.size() - 1;
              going_up = id(up_sequence_active);
              breathe = 100;
              increasing = true;
              it.all() = Color::BLACK;
              return;
            }
            it.all() = Color::BLACK;
            // Breathing effect at lead position
            if (increasing) {
              breathe += 20;
              if (breathe >= 200) increasing = false;
            } else {
              breathe -= 20;
              if (breathe <= 100) increasing = true;
            }
            it[lead_pos] = ESPHSVColor(120, 255, breathe);  // Greenish pulse
            // Trail behind
            for (int i = 1; i < 5; i++) {
              int trail_pos = going_up ? lead_pos - i : lead_pos + i;
              if (trail_pos >= 0 && trail_pos < it.size()) {
                it[trail_pos] = ESPHSVColor(120, 255, 50);  // Dimmer trail
              }
            }
            if (going_up) {
              lead_pos++;
              if (lead_pos >= it.size()) id(effect_finished) = true;
            } else {
              lead_pos--;
              if (lead_pos < 0) id(effect_finished) = true;
            }
      # Sescription: Lights up groups of LEDs (e.g., one group per stair) with a soft fade-in/fade-out, creating a clear path visualization.
      # Use Case: Improves safety by clearly marking each step.
      - addressable_lambda:
          name: "Step Highlight"
          update_interval: 200ms
          lambda: |-
            static uint8_t brightness = 0;
            static bool fading_in = true;
            const uint16_t leds_per_step = 10;  // Adjust based on your stairs
            if (initial_run) {
              brightness = 0;
              fading_in = true;
              it.all() = Color::BLACK;
              return;
            }
            if (fading_in) {
              brightness += 20;
              if (brightness >= 200) fading_in = false;
            } else {
              brightness -= 20;
              if (brightness <= 0) fading_in = true;
            }
            for (int i = 0; i < it.size(); i += leds_per_step) {
              for (int j = 0; j < leds_per_step && (i + j) < it.size(); j++) {
                it[i + j] = ESPHSVColor(40, 100, brightness);  // Warm yellow
              }
            }
            id(effect_finished) = false;  // Runs until stopped
      # Description: A single "wave" of light travels up or down the stairs, bouncing back and forth like a runner, with adjustable speed and color.
      # Use Case: Highlights motion direction and adds a dynamic, playful touch.
      - addressable_lambda:
          name: "Wave Runner"
          update_interval: 50ms
          lambda: |-
            static int position = 0;
            static bool going_up = true;
            static ESPHSVColor wave_color = ESPHSVColor(160, 255, 200);  // Cyan
            if (initial_run) {
              position = 0;
              going_up = id(up_sequence_active);  // Direction based on trigger
              it.all() = Color::BLACK;
              return;
            }
            it.all() = Color::BLACK;  // Clear previous frame
            it[position] = wave_color;
            if (going_up) {
              position++;
              if (position >= it.size() - 1) going_up = false;
            } else {
              position--;
              if (position <= 0) going_up = true;
            }
            id(effect_finished) = false;  // Keep running indefinitely until stopped
## need to find a way to address the update interval better 
      - addressable_lambda:
          name: "Fade Control"
          update_interval: 200ms
          lambda: |-
            static uint16_t progress = 0;
            static bool effect_complete = false;
            static ESPHSVColor on_color = ESPHSVColor(255, 0, 250);   // White-ish (adjustable)
            static ESPHSVColor off_color = ESPHSVColor(255, 255, 0);  // Black

            if (initial_run) {
              progress = 0;
              effect_complete = false;
              it.all() = Color::BLACK;  // Clear LEDs on start
              return;
            }

            ESPHSVColor target_color = id(fade_on) ? on_color : off_color;
            uint16_t group_size = id(led_group_size);

            if (progress < it.size()) {
              if (id(fade_direction_up)) {
                // Fade UP
                for (uint16_t i = 0; i < group_size && (progress + i) < it.size(); i++) {
                  it[progress + i] = target_color;
                }
              } else {
                // Fade DOWN
                for (uint16_t i = 0; i < group_size && (it.size() - progress - i - 1) < it.size(); i++) {
                  it[it.size() - progress - i - 1] = target_color;
                }
              }
              progress += group_size;
              effect_complete = false;
            } else {
              effect_complete = true;
            }

            id(effect_finished) = effect_complete;
